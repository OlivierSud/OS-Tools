<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>G√©n√©rateur de GIF / APNG</title>
  <style>
    :root{ --bg:#061c30; --panel:#082137; --panel-2:#051727; --border:#051727; --text:#d7dde7; --muted:#9aa5b1; --accent1:#4f8cff; --accent2:#7a5cff; --accent3:#4fff95; --accent4:#5cff85; }
    html,body{ height:100%; margin:0; }
    body{ display:flex; flex-direction:column; min-height:100vh; background:var(--bg); color:var(--text); font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; padding:0; }
    #topbar{ display:flex; gap:10px; align-items:center; padding:12px; background:linear-gradient(90deg,#242c3b,#1c1f25); border-bottom:1px solid var(--border); }
    .btn{ border:0; padding:10px 16px; border-radius:10px; color:#fff; font-weight:700; cursor:pointer; background:linear-gradient(135deg,var(--accent1),var(--accent2)); box-shadow:0 6px 16px rgba(79,140,255,.18); transition:transform .12s ease, filter .15s ease; display:inline-block; }
    .btn:hover{ transform:translateY(-2px); background:linear-gradient(135deg,var(--accent3),var(--accent4)); color:#011b0a; }
    .btn:active{ transform:translateY(2px); }
    .wrap{ flex:1; display:flex; flex-direction:column; padding:12px; gap:12px; }
    .card{ background:rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.08); border-radius:12px; padding:12px; }
    h2{ margin:0 0 8px 0; font-size:18px; }
    label{ display:block; margin:6px 0; }
    input[type="file"], input[type="number"], select{ padding:8px; border-radius:10px; border:1px solid rgba(255,255,255,0.2); background:#0f162b; color:var(--text); }
    input:disabled, select:disabled{ opacity:.6; }
    img.preview{ max-height:100px; margin:5px; border-radius:8px; box-shadow:0 0 6px rgba(0,0,0,0.5); }
    #gif-container img{ max-width:600px; width:100%; height:auto; margin-top:10px; border-radius:10px; box-shadow:0 0 12px rgba(0,0,0,0.6); }
    #loading{ font-style:italic; color:var(--muted); margin-top:10px; text-align:center; display:none; }
    #loading span { display:inline-block; animation: pulse 1s infinite; }
    @keyframes pulse { 0%,100% { opacity:1; transform:scale(1);} 50% { opacity:0.5; transform:scale(1.05);} }
    .progress-bar { width:100%; height:8px; background:#1c1f2c; border-radius:6px; overflow:hidden; margin-top:6px; display:none; }
    .progress-fill { height:100%; width:0%; background:linear-gradient(270deg,var(--accent1),var(--accent2),var(--accent3),var(--accent4)); background-size:400% 100%; transition: width 0.2s; }
    .progress-fill.animate { animation: slideGradient 4s linear infinite; }
    @keyframes slideGradient { 0% { background-position:400% 0%; } 100% { background-position:0% 0%; } }
    .options{ margin:10px 0; padding:12px; border-radius:10px; background:#0e1426; border:1px solid rgba(255,255,255,.08); }
    .size-group{ margin-top:8px; }
    .size-disabled{ opacity:.5; pointer-events:none; }
    #preview{ display:flex; flex-wrap:wrap; margin-top:10px; }
    input[type="color"] { padding:0; border:none; background:none; width:40px; height:30px; cursor:pointer; }
    .color-alpha-group { display:flex; align-items:center; gap:12px; margin-top:8px; }
    .color-disabled { opacity:0.5; pointer-events:none; }
    .actions { display:flex; align-items:center; gap:12px; margin-top:10px; flex-wrap:wrap; }
    #file-size { color:var(--muted); font-size:13px; }
    #file-name { padding:8px; border-radius:6px; border:1px solid #444; background:#0f162b; color:var(--text); display:none; }
    .gif-quality-group { margin-top:12px; }
  </style>
</head>
<body>
  <div id="topbar">
    <input type="file" id="images" accept="image/*" multiple hidden>
    <label for="images" class="btn">‚¨áÔ∏è Importer images</label>
  </div>

  <div class="wrap">
    <div class="card">
      <h2>üéûÔ∏è G√©n√©rateur de GIF / APNG anim√©</h2>
      Dur√©e par image (ms): <input type="number" id="duration" value="200" min="10">
      <div class="options">
        <label><input type="checkbox" id="loop" checked> Lire en boucle</label>
        <label><input type="checkbox" id="reverse"> Inverser l‚Äôordre des images</label>
        <label><input type="checkbox" id="use-original-size" checked onchange="toggleSizeInputs()"> Utiliser la taille originale</label>
        <div class="size-group" id="size-group">
          Largeur: <input type="number" id="width" value="500" disabled>
          Hauteur: <input type="number" id="height" value="500" disabled>
          Unit√©:
          <select id="size-unit" disabled>
            <option value="px">px</option>
            <option value="%">%</option>
          </select>
        </div>
        <div class="color-alpha-group">
          <label id="bg-color-label">üé® Couleur de fond (si alpha):
            <input type="color" id="bg-color" value="#000000">
          </label>
          <label><input type="checkbox" id="keep-alpha"> Garder alpha (export APNG)</label>
        </div>
        <!-- Ajout des options de qualit√© GIF -->
        <div class="gif-quality-group" style="margin-top:12px;">
          <label>
            Nombre de couleurs :
            <select id="color-count">
              <option value="2">2</option>
              <option value="4">4</option>
              <option value="8">8</option>
              <option value="16">16</option>
              <option value="32">32</option>
              <option value="64">64</option>
              <option value="128">128</option>
              <option value="256" selected>256</option>
            </select>
          </label>
        </div>
      </div>

      <div class="actions">
        <button class="btn" onclick="generateAnimation()">‚ö° G√©n√©rer</button>
        <a id="download-btn" class="btn" href="#" style="display:none;">üíæ Exporter</a>
        <input type="text" id="file-name" placeholder="Nom du fichier">
        <span id="file-size"></span>
      </div>

      <div id="loading">‚è≥ G√©n√©ration en cours<span></span></div>
      <div class="progress-bar"><div class="progress-fill" id="progress-fill"></div></div>

      <div id="preview"></div>
      <div id="gif-container"></div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/gif.js.optimized/dist/gif.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/upng-js@2.1.0/UPNG.js"></script>

  <!-- NeuQuant (adaptation courte, utilis√©e pour g√©n√©rer la palette) -->
  <script>
    // NeuQuant implementation (lightweight port). Source idea: classic NeuQuant algorithm.
    // Minimal implementation for browser usage to return palette bytes.
    // Note: it's a compact/adjusted version - sufficient to produce a palette.
    function NeuQuant(pixels, samplefac) {
      // pixels: Uint8Array RGBRGB...
      this.pixels = pixels;
      this.samplefac = samplefac || 10;
      this.network = new Array(256);
      for (let i = 0; i < 256; i++) this.network[i] = [ (i<<2), (i<<2), (i<<2), 0 ];
    }
    NeuQuant.prototype.buildColormap = function(colors) {
      // Very simplified learning: pick random samples and fill palette by k-means-ish approach.
      const px = this.pixels;
      const len = px.length;
      const sampleStep = Math.max(1, Math.floor(this.samplefac));
      const palette = [];
      // initialize seeds by sampling
      for (let i=0; i<colors; i++) {
        const idx = ( (i * sampleStep) % (len/3) ) * 3;
        palette.push([px[idx], px[idx+1], px[idx+2]]);
      }
      // few iterations of Lloyd-like relocation
      for (let iter=0; iter<8; iter++) {
        const sums = new Array(colors).fill(0).map(()=>[0,0,0,0]);
        const counts = new Array(colors).fill(0);
        for (let i=0;i<len;i+=3) {
          const r=px[i], g=px[i+1], b=px[i+2];
          let best=0, bd=1e9;
          for (let j=0;j<colors;j++){
            const p=palette[j];
            const d=(r-p[0])*(r-p[0])+(g-p[1])*(g-p[1])+(b-p[2])*(b-p[2]);
            if (d<bd){bd=d; best=j;}
          }
          sums[best][0]+=r; sums[best][1]+=g; sums[best][2]+=b; counts[best]++;
        }
        for (let j=0;j<colors;j++){
          if (counts[j]>0) {
            palette[j][0] = Math.round(sums[j][0]/counts[j]);
            palette[j][1] = Math.round(sums[j][1]/counts[j]);
            palette[j][2] = Math.round(sums[j][2]/counts[j]);
          }
        }
      }
      // flatten to Uint8Array
      const out = new Uint8Array(colors*3);
      for (let i=0;i<colors;i++){ out[i*3]=palette[i][0]; out[i*3+1]=palette[i][1]; out[i*3+2]=palette[i][2]; }
      return out;
    };
  </script>
  
  <script>
    fetch("https://cdn.jsdelivr.net/npm/gif.js.optimized/dist/gif.worker.js")
      .then(r => r.text())
      .then(code => {
        const workerBlob = new Blob([code], { type: "application/javascript" });
        const workerURL = URL.createObjectURL(workerBlob);
        window.startApp(workerURL);
      });

    function toggleSizeInputs() {
      const checked = document.getElementById('use-original-size').checked;
      const group = document.getElementById('size-group');
      const inputs = group.querySelectorAll('input, select');
      inputs.forEach(input => input.disabled = checked);
      group.classList.toggle('size-disabled', checked);
    }

    function startApp(workerURL) {
      const imagesInput = document.getElementById('images');
      const previewDiv = document.getElementById('preview');
      const container = document.getElementById('gif-container');
      const loading = document.getElementById('loading');
      const progressBar = document.querySelector('.progress-bar');
      const progressFill = document.getElementById('progress-fill');
      const downloadBtn = document.getElementById('download-btn');
      const fileSizeSpan = document.getElementById('file-size');
      const fileNameInput = document.getElementById('file-name');

      const loopCb = document.getElementById('loop');
      const reverseCb = document.getElementById('reverse');
      const sizeCb = document.getElementById('use-original-size');
      const widthInput = document.getElementById('width');
      const heightInput = document.getElementById('height');
      const unitInput = document.getElementById('size-unit');
      const bgColorInput = document.getElementById('bg-color');
      const bgColorLabel = document.getElementById('bg-color-label');
      const keepAlphaCb = document.getElementById('keep-alpha');
      // Ajout des nouveaux contr√¥les
      const colorCountInput = document.getElementById('color-count');
      // Fonction de r√©duction de couleurs + tramage (Floyd‚ÄìSteinberg)
      function applyPalette(imageData, paletteBytes) {
        const w = imageData.width, h = imageData.height;
        const data = imageData.data;
        const palN = paletteBytes.length / 3;
        const palette = [];
        for (let i=0;i<palN;i++) palette.push([paletteBytes[i*3], paletteBytes[i*3+1], paletteBytes[i*3+2]]);
        // map chaque pixel au plus proche (sans diffusion d'erreur)
        for (let y=0; y<h; y++){
          for (let x=0; x<w; x++){
            const idx = (y*w + x)*4;
            const a = data[idx+3];
            if (a < 128) { data[idx]=data[idx+1]=data[idx+2]=0; data[idx+3]=0; continue; }
            const r = data[idx], g = data[idx+1], b = data[idx+2];
            let best=0, bd=1e9;
            for (let p=0;p<palN;p++){
              const pc = palette[p];
              const dd = (r-pc[0])*(r-pc[0]) + (g-pc[1])*(g-pc[1]) + (b-pc[2])*(b-pc[2]);
              if (dd < bd){ bd = dd; best = p; }
            }
            data[idx] = palette[best][0];
            data[idx+1] = palette[best][1];
            data[idx+2] = palette[best][2];
          }
        }
      }

      // Construire une palette globale √† partir d'un √©chantillon des frames (utilise NeuQuant ci-dessus)
      async function buildPalette(images, w, h, colorCount) {
        const tmp = document.createElement('canvas');
        tmp.width = w; tmp.height = h;
        const tctx = tmp.getContext('2d');
        const samplePixels = [];
        const maxSamples = 200000; // limite d'√©chantillons
        for (let k = 0; k < images.length; k++) {
          tctx.clearRect(0, 0, w, h);
          tctx.drawImage(images[k], 0, 0, w, h);
          const id = tctx.getImageData(0, 0, w, h).data;
          // √©tape pour limiter le nombre d'√©chantillons
          const step = Math.max(1, Math.floor((w * h) / Math.max(1, Math.floor(maxSamples / images.length))));
          for (let i = 0; i < id.length; i += 4 * step) {
            if (id[i+3] < 128) continue; // ignorer transparent
            samplePixels.push(id[i], id[i+1], id[i+2]);
          }
        }
        if (samplePixels.length === 0) {
          // fallback : palette grayscale
          const out = new Uint8Array(colorCount * 3);
          for (let i = 0; i < colorCount; i++) {
            const v = Math.round(i * (255 / Math.max(1, colorCount - 1)));
            out[i*3] = out[i*3+1] = out[i*3+2] = v;
          }
          return out;
        }
        const pixelsArr = new Uint8Array(samplePixels);
        const nq = new NeuQuant(pixelsArr, 10);
        return nq.buildColormap(colorCount);
      }

      let files = [];

      imagesInput.addEventListener('change', e => {
        files = Array.from(e.target.files);
        previewDiv.innerHTML = '';
        container.innerHTML = '';
        downloadBtn.style.display = 'none';
        fileSizeSpan.textContent = '';
        fileNameInput.style.display = 'none';
        if(files.length>0){
          const firstName = files[0].name.split('.').slice(0,-1).join('.');
          fileNameInput.value = firstName; // valeur par d√©faut
          fileNameInput.placeholder = firstName;
        }
        files.forEach(file => {
          const img = document.createElement('img');
          img.src = URL.createObjectURL(file);
          img.className = "preview";
          previewDiv.appendChild(img);
        });
      });

      keepAlphaCb.addEventListener('change', () => {
        if (keepAlphaCb.checked) {
          bgColorLabel.classList.add("color-disabled");
          bgColorInput.disabled = true;
        } else {
          bgColorLabel.classList.remove("color-disabled");
          bgColorInput.disabled = false;
        }
      });

      window.generateAnimation = function () {
        const durationValue = parseInt(document.getElementById('duration').value) || 200;
        const shouldLoop = loopCb.checked;
        const shouldReverse = reverseCb.checked;
        const useOriginalSize = sizeCb.checked;
        const keepAlpha = keepAlphaCb.checked;
        const bgColor = bgColorInput.value;
        // R√©cup√©ration des options de qualit√© GIF
        const colorCount = parseInt(colorCountInput.value, 10);

        container.innerHTML = '';
        downloadBtn.style.display = 'none';
        fileNameInput.style.display = 'inline-block';
        fileSizeSpan.textContent = '';
        loading.style.display = 'block';
        progressBar.style.display = 'block';
        progressFill.style.width = "0%";

        // Relancer l'animation de gradient
        progressFill.classList.remove('animate');
        void progressFill.offsetWidth;
        progressFill.classList.add('animate');

        const loadImgs = files.map(file => new Promise((res, rej) => {
          const img = new Image();
          img.onload = () => res(img);
          img.onerror = () => rej("Erreur : " + file.name);
          img.src = URL.createObjectURL(file);
        }));

        Promise.all(loadImgs).then(async images => {
           if (shouldReverse) images.reverse();
           let width = images[0].width;
           let height = images[0].height;
           if (!useOriginalSize) {
             const w = parseFloat(widthInput.value);
             const h = parseFloat(heightInput.value);
             if(unitInput.value === '%') { width = Math.round(images[0].width*(w/100)); height = Math.round(images[0].height*(h/100)); }
             else { width = w; height = h; }
           }
          // si on demande une palette r√©duite, on la construit globalement avant d'ajouter les frames
          let globalPalette = null;
          if (!keepAlpha && colorCount && colorCount < 256) {
            progressFill.style.width = "5%";
            globalPalette = await buildPalette(images, width, height, colorCount);
            progressFill.style.width = "10%";
          }
 
           // === Nom du fichier pris en compte correctement d√®s la premi√®re g√©n√©ration ===
           const currentFileName = fileNameInput.value.trim() || (files[0]? files[0].name.split('.').slice(0,-1).join('.') : "animation");
 
           if(keepAlpha) {
             const frames = [];
             const delays = [];
             const canvas = document.createElement('canvas'); canvas.width=width; canvas.height=height;
             const ctx = canvas.getContext('2d');
             images.forEach((img,i)=>{
               ctx.clearRect(0,0,width,height);
               ctx.drawImage(img,0,0,width,height);
               frames.push(ctx.getImageData(0,0,width,height).data.buffer);
               delays.push(durationValue);
               progressFill.style.width = ((i+1)/images.length*70) + "%";
             });
             const apng = UPNG.encode(frames,width,height,0,delays);
             const blob = new Blob([apng],{type:"image/apng"});
             const url = URL.createObjectURL(blob);
             const out = document.createElement('img'); out.src=url; container.appendChild(out);
             progressFill.style.width="100%"; progressFill.classList.remove('animate');
             downloadBtn.href=url; downloadBtn.download=currentFileName+".apng"; downloadBtn.textContent="üíæ Exporter en APNG"; downloadBtn.style.display="inline-block";
             fileSizeSpan.textContent="("+ (blob.size/(1024*1024)).toFixed(2)+" Mo)";
             loading.style.display="none";
           } else {
             // Cr√©ation du GIF
             const gif = new GIF({
               workers: 2,
               quality: 10,
               workerScript: workerURL,
               repeat: shouldLoop ? 0 : -1
             });
             // si palette globale, transmettre palette + colors √† gif.js pour forcer la palette finale
             if (globalPalette) {
               // gif.js.optimized accepte 'palette' comme tableau ou Uint8Array
               gif.setOptions({ width, height, colors: colorCount, palette: Array.from(globalPalette) });
             } else {
               gif.setOptions({ width, height });
             }
             const canvas = document.createElement('canvas'); canvas.width = width; canvas.height = height;
             const ctx = canvas.getContext('2d');
             images.forEach((img, i) => {
               ctx.clearRect(0, 0, width, height);
               ctx.fillStyle = bgColor; ctx.fillRect(0, 0, width, height);
               ctx.drawImage(img, 0, 0, width, height);
               // si on a construit une palette globale, appliquer quantification par frame (mapping au plus proche)
               if (globalPalette) {
                 const imgData = ctx.getImageData(0, 0, width, height);
                 applyPalette(imgData, globalPalette);
                 ctx.putImageData(imgData, 0, 0);
               }
               gif.addFrame(ctx, { delay: durationValue, copy: true });
               progressFill.style.width = ((i + 1) / images.length * 70) + "%";
             });
             gif.on('finished', blob=>{
               const result=document.createElement('img'); result.src=URL.createObjectURL(blob);
               container.innerHTML=''; container.appendChild(result);
               progressFill.style.width="100%"; progressFill.classList.remove('animate');
               downloadBtn.href=result.src; downloadBtn.download=currentFileName+".gif"; downloadBtn.textContent="üíæ Exporter en GIF"; downloadBtn.style.display="inline-block";
               fileSizeSpan.textContent="("+ (blob.size/(1024*1024)).toFixed(2)+" Mo)";
               loading.style.display="none";
             });
             gif.render();
           }

        }).catch(err=>{
          alert(err); loading.style.display='none'; progressBar.style.display='none'; progressFill.classList.remove('animate');
        });
      };
     }
   </script>
</body>
</html>
