<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Générateur de Normal Map v3.1</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #333;
            color: #f0f0f0;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }
        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            width: 100%;
            max-width: 1200px;
        }
        .panel {
            background-color: #444;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .controls-panel {
            flex: 1;
            min-width: 300px;
        }
        .preview-panel {
            flex: 2;
            min-width: 400px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1, h2 {
            border-bottom: 2px solid #555;
            padding-bottom: 10px;
            margin-top: 0;
            color: #00aaff;
        }
        .control-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 8px; font-weight: bold; }
        .checkbox-label { display: inline-block; margin-left: 5px; font-weight: normal; }
        input[type="file"] { padding: 8px; background-color: #555; border-radius: 4px; cursor: pointer; }
        input[type="range"] { width: 100%; cursor: pointer; }
        
        .main-preview-container { position: relative; width: 100%; max-width: 512px; }
        #normalMapCanvas, #mainPreviewImage { width: 100%; height: auto; border-radius: 4px; background-color: #3a3a3a; image-rendering: pixelated; }
        #mainPreviewImage { display: none; }

        .view-switcher { margin-bottom: 15px; display: flex; gap: 10px; background-color: #333; padding: 5px; border-radius: 8px; }
        .view-switcher button { padding: 5px 15px; border: 1px solid #555; background-color: #444; color: #eee; cursor: pointer; border-radius: 5px; font-weight: normal; }
        .view-switcher button.active { background-color: #00aaff; color: #fff; border-color: #00aaff; }

        #threeCanvas {
            width: 100%;
            height: 400px;
            border-radius: 4px;
            margin-top: 10px;
        }
        #shape-switcher button {
            flex: 1;
        }

        .value-display { display: inline-block; margin-left: 10px; font-weight: normal; color: #ccc; }
        .options-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    </style>
</head>
<body>

<div class="container">
    <div class="panel controls-panel">
        <h1>Paramètres</h1>

        <div class="control-group">
            <label for="imageLoader">1. Importer un fichier source</label>
            <input type="file" id="imageLoader" name="imageLoader" accept="image/*"/>
        </div>

        <div class="control-group" id="heightmapControls">
            <h2>2. Génération de la Heightmap</h2>
            <input type="checkbox" id="enableHeightmap" checked>
            <label for="enableHeightmap" class="checkbox-label">Activer la génération de Heightmap</label>
            
            <div id="heightmap-options" style="margin-top: 10px;">
                <label for="blurAmount">Flou <span id="blurAmountValue" class="value-display">0.0</span></label>
                <input type="range" id="blurAmount" min="0" max="5" value="0" step="0.1">

                <label for="levelsAmount">Niveaux (Contraste) <span id="levelsAmountValue" class="value-display">1.0</span></label>
                <input type="range" id="levelsAmount" min="0" max="3" value="1" step="0.05">
            </div>
        </div>

        <div class="control-group">
            <h2>3. Réglages de la Normal Map</h2>
            <label for="intensity">Intensité <span id="intensityValue" class="value-display">1.00</span></label>
            <input type="range" id="intensity" min="0" max="100" value="50" step="1">

            <label for="smallDetails">Petits Détails (Lissage) <span id="smallDetailsValue" class="value-display">1.00</span></label>
            <input type="range" id="smallDetails" min="0" max="1" value="1" step="0.01">

            <label for="mediumDetails">Moyens Détails <span id="mediumDetailsValue" class="value-display">0.00</span></label>
            <input type="range" id="mediumDetails" min="0" max="1" value="0" step="0.01">

            <label for="largeDetails">Grands Détails <span id="largeDetailsValue" class="value-display">0.00</span></label>
            <input type="range" id="largeDetails" min="0" max="1" value="0" step="0.01">
        </div>
        
        <div class="control-group">
            <h2>4. Options des canaux</h2>
            <div class="options-grid">
                <div>
                    <label>Format</label>
                    <input type="radio" id="formatOpenGL" name="format" value="opengl" checked>
                    <label for="formatOpenGL" class="checkbox-label">OpenGL</label><br>
                    <input type="radio" id="formatDirectX" name="format" value="directx">
                    <label for="formatDirectX" class="checkbox-label">DirectX</label>
                </div>
                <div>
                    <label>Inverser</label>
                    <input type="checkbox" id="invertR">
                    <label for="invertR" class="checkbox-label">R (X)</label><br>
                    <input type="checkbox" id="invertG">
                    <label for="invertG" class="checkbox-label">V (Y)</label><br>
                    <input type="checkbox" id="invertB">
                    <label for="invertB" class="checkbox-label">B (Z)</label>
                </div>
            </div>
        </div>
    </div>

    <div class="panel preview-panel">
        <h2>Aperçu</h2>
        <div class="view-switcher">
            <button id="viewNormalBtn" class="active">Normal Map</button>
            <button id="viewHeightmapBtn">Heightmap</button>
            <button id="viewSourceBtn">Source</button>
        </div>
        <div class="main-preview-container">
            <canvas id="normalMapCanvas" width="512" height="512"></canvas>
            <img id="mainPreviewImage" src="" alt="Aperçu principal" />
        </div>

        <div class="control-group" style="margin-top: 20px; width: 100%; max-width: 512px;">
            <h2 style="font-size: 1.2em; margin-bottom: 10px;">Aperçu 3D</h2>
            <div class="view-switcher" id="shape-switcher">
                <button id="viewCubeBtn" class="active">Cube</button>
                <button id="viewSphereBtn">Sphère</button>
            </div>
            <canvas id="threeCanvas"></canvas>
            <div style="margin-top: 10px; width: 100%;">
                <label for="roughnessSlider">Rugosité <span id="roughnessValue" class="value-display">0.6</span></label>
                <input type="range" id="roughnessSlider" min="0" max="1" value="0.6" step="0.01">
            </div>
        </div>
    </div>
</div>

<script>
    // Elements DOM
    const imageLoader = document.getElementById('imageLoader');
    const normalMapCanvas = document.getElementById('normalMapCanvas');
    const ctx = normalMapCanvas.getContext('2d');

    // Éléments pour l'aperçu principal
    const mainPreviewImage = document.getElementById('mainPreviewImage');
    const viewNormalBtn = document.getElementById('viewNormalBtn');
    const viewHeightmapBtn = document.getElementById('viewHeightmapBtn');
    const viewSourceBtn = document.getElementById('viewSourceBtn');
    const viewSwitcherBtns = [viewNormalBtn, viewHeightmapBtn, viewSourceBtn];

    // Contrôles des options
    const intensitySlider = document.getElementById('intensity');
    const smallDetailsSlider = document.getElementById('smallDetails');
    const mediumDetailsSlider = document.getElementById('mediumDetails');
    const largeDetailsSlider = document.getElementById('largeDetails');
    
    const intensityValue = document.getElementById('intensityValue');
    const smallDetailsValue = document.getElementById('smallDetailsValue');
    const mediumDetailsValue = document.getElementById('mediumDetailsValue');
    const largeDetailsValue = document.getElementById('largeDetailsValue');

    const enableHeightmap = document.getElementById('enableHeightmap');
    const heightmapOptions = document.getElementById('heightmap-options');
    const blurSlider = document.getElementById('blurAmount');
    const levelsSlider = document.getElementById('levelsAmount');
    const blurValue = document.getElementById('blurAmountValue');
    const levelsValue = document.getElementById('levelsAmountValue');
    const roughnessSlider = document.getElementById('roughnessSlider');
    const roughnessValue = document.getElementById('roughnessValue');

    const formatOpenGL = document.getElementById('formatOpenGL');
    const formatDirectX = document.getElementById('formatDirectX');
    const invertR = document.getElementById('invertR');
    const invertG = document.getElementById('invertG');
    const invertB = document.getElementById('invertB');

    // Variables Babylon.js
    let engine, scene, pbrMaterial, cube, sphere, currentMesh;

    let sourceImage = new Image();
    let sourceCanvas = document.createElement('canvas');
    let sourceCtx = sourceCanvas.getContext('2d');
    let heightmapCanvas = document.createElement('canvas');
    let heightmapCtx = heightmapCanvas.getContext('2d');

    function updateValueDisplay() {
        const intensityRaw = parseFloat(intensitySlider.value) / 100;
        const strength = Math.pow(intensityRaw, 2) * 2.5;
        intensityValue.textContent = strength.toFixed(2);
        smallDetailsValue.textContent = parseFloat(smallDetailsSlider.value).toFixed(2);
        mediumDetailsValue.textContent = parseFloat(mediumDetailsSlider.value).toFixed(2);
        largeDetailsValue.textContent = parseFloat(largeDetailsSlider.value).toFixed(2);
        blurValue.textContent = parseFloat(blurSlider.value).toFixed(1);
        levelsValue.textContent = parseFloat(levelsSlider.value).toFixed(2);
        roughnessValue.textContent = parseFloat(roughnessSlider.value).toFixed(2);
    }

    function handleFormatChange() {
        if (formatDirectX.checked) {
            invertG.checked = true;
            invertG.disabled = true;
        } else {
            invertG.checked = false;
            invertG.disabled = false;
        }
        generateNormalMap();
    }
    
    imageLoader.addEventListener('change', e => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = event => {
            sourceImage.onload = () => {
                sourceCanvas.width = sourceImage.width;
                sourceCanvas.height = sourceImage.height;
                heightmapCanvas.width = sourceImage.width;
                heightmapCanvas.height = sourceImage.height;
                normalMapCanvas.width = sourceImage.width;
                normalMapCanvas.height = sourceImage.height;

                // Créer/remplacer les textures 3D uniquement lors du chargement d'une nouvelle image
                if (pbrMaterial) {
                    if (pbrMaterial.albedoTexture) pbrMaterial.albedoTexture.dispose();
                    pbrMaterial.albedoTexture = new BABYLON.Texture(sourceImage.src, scene);

                    if (pbrMaterial.bumpTexture) pbrMaterial.bumpTexture.dispose();
                    pbrMaterial.bumpTexture = new BABYLON.DynamicTexture("normalMap", normalMapCanvas, scene, false);
                }

                generateHeightmap();
                setActiveView(viewNormalBtn); // Afficher la normal map par défaut
            };
            sourceImage.src = event.target.result;
        }
        reader.readAsDataURL(file);
    });

    const parameterControls = [
        intensitySlider, smallDetailsSlider, mediumDetailsSlider, largeDetailsSlider,
        invertR, invertG, invertB
    ];
    parameterControls.forEach(control => control.addEventListener('input', () => {
        updateValueDisplay();
        generateNormalMap();
    }));

    // Nouveaux écouteurs
    enableHeightmap.addEventListener('change', () => {
        heightmapOptions.style.display = enableHeightmap.checked ? 'block' : 'none';
        generateHeightmap();
    });
    blurSlider.addEventListener('input', () => {
        updateValueDisplay();
        generateHeightmap();
    });
    levelsSlider.addEventListener('input', () => {
        updateValueDisplay();
        generateHeightmap();
    });
    
    roughnessSlider.addEventListener('input', () => {
        if (pbrMaterial) {
            pbrMaterial.roughness = parseFloat(roughnessSlider.value);
        }
        updateValueDisplay();
    });

    formatOpenGL.addEventListener('change', handleFormatChange);
    formatDirectX.addEventListener('change', handleFormatChange);
    
    function getPixel(imageData, x, y) {
        if (x < 0 || x >= imageData.width || y < 0 || y >= imageData.height) return 0;
        const i = (y * imageData.width + x) * 4;
        return imageData.data[i] * 0.299 + imageData.data[i + 1] * 0.587 + imageData.data[i + 2] * 0.114;
    }

    function generateHeightmap() {
        if (!sourceImage.src) return;
        const width = sourceCanvas.width;
        const height = sourceCanvas.height;

        heightmapCtx.clearRect(0, 0, width, height);

        if (enableHeightmap.checked) {
            const blur = parseFloat(blurSlider.value);
            const levels = parseFloat(levelsSlider.value);

            // 1. Dessiner l'image source et appliquer le flou
            heightmapCtx.filter = `blur(${blur}px) grayscale(1)`;
            heightmapCtx.drawImage(sourceImage, 0, 0);
            heightmapCtx.filter = 'none';

            // 2. Appliquer l'ajustement des niveaux (contraste)
            const imageData = heightmapCtx.getImageData(0, 0, width, height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                let val = data[i]; // L'image est déjà en niveaux de gris
                val = ((val / 255 - 0.5) * levels + 0.5) * 255;
                val = Math.max(0, Math.min(255, val)); // Clamp
                data[i] = data[i + 1] = data[i + 2] = val;
            }
            heightmapCtx.putImageData(imageData, 0, 0);
        } else {
            // Si désactivé, on utilise juste l'image source
            heightmapCtx.drawImage(sourceImage, 0, 0);
        }

        generateNormalMap();
    }

    function generateNormalMap() {
        if (!sourceImage.src) return;

        const width = heightmapCanvas.width;
        const height = heightmapCanvas.height;
        
        // Échelle logarithmique pour l'intensité pour un meilleur contrôle des basses valeurs
        const intensityRaw = parseFloat(intensitySlider.value) / 100; // 0 to 1
        const strength = Math.pow(intensityRaw, 2) * 2.5; // 0 to 2.5, avec plus de précision en bas
        
        const sStr = parseFloat(smallDetailsSlider.value);
        const mStr = parseFloat(mediumDetailsSlider.value);
        const lStr = parseFloat(largeDetailsSlider.value);

        // --- NOUVELLE LOGIQUE DE LISSAGE ---
        const maxBlur = 4; 
        const blurAmount = 1.0 - sStr;
        const blurRadius = maxBlur * Math.pow(blurAmount, 2);

        sourceCtx.clearRect(0, 0, width, height);
        sourceCtx.filter = `blur(${blurRadius}px)`;
        sourceCtx.drawImage(heightmapCanvas, 0, 0); // Utilise la heightmap comme source
        sourceCtx.filter = 'none';

        const srcData = sourceCtx.getImageData(0, 0, width, height);
        const destImageData = ctx.createImageData(width, height);
        const destData = destImageData.data;

        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const n_x1 = getPixel(srcData, x - 1, y), n_x2 = getPixel(srcData, x + 1, y);
                const n_y1 = getPixel(srcData, x, y - 1), n_y2 = getPixel(srcData, x, y + 1);
                const m_x1 = getPixel(srcData, x - 2, y), m_x2 = getPixel(srcData, x + 2, y);
                const m_y1 = getPixel(srcData, x, y - 2), m_y2 = getPixel(srcData, x, y + 2);
                const l_x1 = getPixel(srcData, x - 4, y), l_x2 = getPixel(srcData, x + 4, y);
                const l_y1 = getPixel(srcData, x, y - 4), l_y2 = getPixel(srcData, x, y + 4);
                
                let dx = (n_x2 - n_x1) * sStr + (m_x2 - m_x1) * mStr + (l_x2 - l_x1) * lStr;
                let dy = (n_y2 - n_y1) * sStr + (m_y2 - m_y1) * mStr + (l_y2 - l_y1) * lStr;

                let normal = { x: -dx * strength, y: -dy * strength, z: 1.0 };
                
                const len = Math.sqrt(normal.x*normal.x + normal.y*normal.y + normal.z*normal.z);
                if (len > 0) { normal.x /= len; normal.y /= len; normal.z /= len; }

                let r = (normal.x * 0.5 + 0.5) * 255;
                let g = (normal.y * 0.5 + 0.5) * 255;
                let b = (normal.z * 0.5 + 0.5) * 255;

                if (invertR.checked) r = 255 - r;
                if (invertG.checked) g = 255 - g;
                if (invertB.checked) b = 255 - b;

                const index = (y * width + x) * 4;
                destData[index] = r;
                destData[index + 1] = g;
                destData[index + 2] = b;
                destData[index + 3] = 255;
            }
        }
        ctx.putImageData(destImageData, 0, 0);
        
        // Mettre à jour l'aperçu principal si la vue active est la heightmap
        if (viewHeightmapBtn.classList.contains('active')) {
            mainPreviewImage.src = heightmapCanvas.toDataURL();
        }
        updateBabylonTextures();
    }
    
    function setActiveView(activeBtn) {
        viewSwitcherBtns.forEach(btn => btn.classList.remove('active'));
        activeBtn.classList.add('active');

        const view = activeBtn.id;
        if (view === 'viewNormalBtn') {
            mainPreviewImage.style.display = 'none';
            normalMapCanvas.style.display = 'block';
        } else {
            if (view === 'viewHeightmapBtn') {
                mainPreviewImage.src = heightmapCanvas.toDataURL();
            } else if (view === 'viewSourceBtn') {
                mainPreviewImage.src = sourceImage.src;
            }
            mainPreviewImage.style.display = 'block';
            normalMapCanvas.style.display = 'none';
        }
    }

    viewNormalBtn.addEventListener('click', () => setActiveView(viewNormalBtn));
    viewHeightmapBtn.addEventListener('click', () => setActiveView(viewHeightmapBtn));
    viewSourceBtn.addEventListener('click', () => setActiveView(viewSourceBtn));

    // --- Initialisation de la scène 3D ---
    initBabylon();

    function initBabylon() {
        const babylonCanvas = document.getElementById('threeCanvas');
        engine = new BABYLON.Engine(babylonCanvas, true, { preserveDrawingBuffer: true, stencil: true });
        scene = new BABYLON.Scene(engine);

        const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 3, new BABYLON.Vector3(0, 0, 0), scene);
        camera.attachControl(babylonCanvas, true);
        camera.wheelPrecision = 0; // Bloque le zoom

        const hdrTexture = new BABYLON.CubeTexture.CreateFromPrefilteredData("https://assets.babylonjs.com/environments/environmentSpecular.env", scene);
        scene.environmentTexture = hdrTexture;
        scene.createDefaultSkybox(hdrTexture, true, 1000, 0.0);

        pbrMaterial = new BABYLON.PBRMaterial("pbr", scene);
        pbrMaterial.metallic = 0.2;
        pbrMaterial.roughness = 0.6;

        cube = BABYLON.MeshBuilder.CreateBox("cube", {size: 1}, scene);
        cube.material = pbrMaterial;

        sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: 1.4, segments: 64}, scene);
        sphere.material = pbrMaterial;
        sphere.setEnabled(false);

        currentMesh = cube;

        const viewCubeBtn = document.getElementById('viewCubeBtn');
        const viewSphereBtn = document.getElementById('viewSphereBtn');

        viewCubeBtn.addEventListener('click', () => {
            if (currentMesh !== cube) {
                cube.setEnabled(true);
                sphere.setEnabled(false);
                currentMesh = cube;
                viewCubeBtn.classList.add('active');
                viewSphereBtn.classList.remove('active');
            }
        });

        viewSphereBtn.addEventListener('click', () => {
            if (currentMesh !== sphere) {
                sphere.setEnabled(true);
                cube.setEnabled(false);
                currentMesh = sphere;
                viewSphereBtn.classList.add('active');
                viewCubeBtn.classList.remove('active');
            }
        });
        
        engine.runRenderLoop(() => {
            scene.render();
        });

        window.addEventListener('resize', () => {
            engine.resize();
        });
    }

    function updateBabylonTextures() {
        // Mettre à jour uniquement la DynamicTexture de la normal map.
        // L'albedo ne change pas avec les curseurs.
        if (pbrMaterial && pbrMaterial.bumpTexture) {
            pbrMaterial.bumpTexture.update();
        }
    }

    updateValueDisplay();
    handleFormatChange();
</script>

</body>
</html>