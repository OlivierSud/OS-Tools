<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Générateur de Normal Map v3.1</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #333;
            color: #f0f0f0;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            height: 100vh;
            box-sizing: border-box;
            overflow: hidden;
        }
        .container {
            display: flex;
            flex-wrap: nowrap;
            gap: 30px;
            width: 100%;
            max-width: 1200px;
            height: 100%;
        }
        .panel {
            background-color: #444;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            overflow-y: auto;
            height: 100%;
            box-sizing: border-box;
        }
        .controls-panel {
            flex: 1;
            min-width: 300px;
        }
        .preview-panel {
            flex: 2;
            min-width: 400px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1, h2 {
            border-bottom: 2px solid #555;
            padding-bottom: 10px;
            margin-top: 0;
            color: #00aaff;
        }
        .control-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 8px; font-weight: bold; }
        .checkbox-label { display: inline-block; margin-left: 5px; font-weight: normal; }
        input[type="file"] { padding: 8px; background-color: #555; border-radius: 4px; cursor: pointer; }
        input[type="range"] { width: 100%; cursor: pointer; }
        
        .main-preview-container { position: relative; width: 100%; max-width: 512px; }
        #normalMapCanvas, #mainPreviewImage { width: 100%; height: auto; border-radius: 4px; background-color: #3a3a3a; image-rendering: pixelated; }
        #mainPreviewImage { display: none; }

        .view-switcher { margin-bottom: 15px; display: flex; gap: 10px; background-color: #333; padding: 5px; border-radius: 8px; }
        .view-switcher button { padding: 5px 15px; border: 1px solid #555; background-color: #444; color: #eee; cursor: pointer; border-radius: 5px; font-weight: normal; }
        .view-switcher button.active { background-color: #00aaff; color: #fff; border-color: #00aaff; }

        #threeCanvas {
            width: 100%;
            height: 400px;
            border-radius: 4px;
            margin-top: 10px;
        }
        #shape-switcher button {
            flex: 1;
        }

        .value-display { display: inline-block; margin-left: 10px; font-weight: normal; color: #ccc; }
        .options-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    </style>
</head>
<body>

<div class="container">
    <div class="panel controls-panel">
        <h1>Paramètres</h1>

        <div class="control-group">
            <label for="imageLoader">1. Importer un fichier source</label>
            <input type="file" id="imageLoader" name="imageLoader" accept="image/*"/>
        </div>

        <div class="control-group" id="heightmapControls">
            <h2>2. Génération de la Heightmap</h2>
            <input type="checkbox" id="enableHeightmap" checked>
            <label for="enableHeightmap" class="checkbox-label">Activer la génération de Heightmap</label>
            
            <div id="heightmap-options" style="margin-top: 10px;">
                <label for="hmLargeShapes">Formes Larges <span id="hmLargeShapesValue" class="value-display">0.60</span></label>
                <input type="range" id="hmLargeShapes" min="0" max="1" value="0.6" step="0.05">

                <label for="hmMediumDetails">Détails Moyens <span id="hmMediumDetailsValue" class="value-display">0.60</span></label>
                <input type="range" id="hmMediumDetails" min="0" max="3" value="0.6" step="0.05">

                <label for="hmFineDetails">Détails Fins <span id="hmFineDetailsValue" class="value-display">0.60</span></label>
                <input type="range" id="hmFineDetails" min="0" max="3" value="0.6" step="0.05">
                
                <label for="hmIntensity">Intensité Globale <span id="hmIntensityValue" class="value-display">2.00</span></label>
                <input type="range" id="hmIntensity" min="0" max="3" value="2.0" step="0.05">

                <label for="hmSmoothing">Lissage Final <span id="hmSmoothingValue" class="value-display">2.0</span></label>
                <input type="range" id="hmSmoothing" min="0" max="5" value="2.0" step="0.1">
            </div>
        </div>

        <div class="control-group">
            <h2>3. Réglages de la Normal Map</h2>
            <label for="intensity">Intensité <span id="intensityValue" class="value-display">1.00</span></label>
            <input type="range" id="intensity" min="0" max="100" value="63" step="1">

            <label for="smallDetails">Petits Détails (Lissage) <span id="smallDetailsValue" class="value-display">0.10</span></label>
            <input type="range" id="smallDetails" min="0" max="1" value="0.1" step="0.01">

            <label for="mediumDetails">Moyens Détails <span id="mediumDetailsValue" class="value-display">0.10</span></label>
            <input type="range" id="mediumDetails" min="0" max="1" value="0.1" step="0.01">

            <label for="largeDetails">Grands Détails <span id="largeDetailsValue" class="value-display">0.10</span></label>
            <input type="range" id="largeDetails" min="0" max="1" value="0.1" step="0.01">
        </div>
        
        <div class="control-group">
            <h2>4. Roughness Map (nouveau)</h2>
            <label for="roughDarkIntensity">Intensité tons sombres <span id="roughDarkValue" class="value-display">1.00</span></label>
            <input type="range" id="roughDarkIntensity" min="0" max="2" value="1" step="0.01">

            <label for="roughLightIntensity">Intensité tons clairs <span id="roughLightValue" class="value-display">1.00</span></label>
            <input type="range" id="roughLightIntensity" min="0" max="2" value="1" step="0.01">

            <div style="margin-top:8px;">
              <label>Levels (Photoshop-like)</label>
              <label for="levelsBlack">Noir <span id="levelsBlackValue" class="value-display">0</span></label>
              <input type="range" id="levelsBlack" min="0" max="255" value="0" step="1">
              <label for="levelsGamma">Gamma <span id="levelsGammaValue" class="value-display">1.00</span></label>
              <input type="range" id="levelsGamma" min="0.1" max="5" value="1" step="0.01">
              <label for="levelsWhite">Blanc <span id="levelsWhiteValue" class="value-display">255</span></label>
              <input type="range" id="levelsWhite" min="0" max="255" value="255" step="1">
            </div>

            <label style="margin-top:8px;"><input type="checkbox" id="invertRough"> Inverser noir/blanc</label>
        </div>

        <div class="control-group" style="margin-top:6px;">
            <button id="regenerateRoughBtn" class="btn" type="button">Générer Roughness</button>
        </div>
    </div>

    <div class="panel preview-panel">
        <h2>Aperçu</h2>
        <div class="view-switcher">
            <button id="viewNormalBtn" class="active">Normal Map</button>
            <button id="viewHeightmapBtn">Heightmap</button>
            <button id="viewSourceBtn">Source</button>
            <button id="viewRoughBtn">Roughness</button>
        </div>
        <div class="main-preview-container">
            <canvas id="normalMapCanvas" width="512" height="512"></canvas>
            <img id="mainPreviewImage" src="" alt="Aperçu principal" />
        </div>

        <div class="control-group" style="margin-top: 20px; width: 100%; max-width: 512px;">
            <h2 style="font-size: 1.2em; margin-bottom: 10px;">Aperçu 3D</h2>
            <div class="view-switcher" id="shape-switcher">
                <button id="viewCubeBtn" class="active">Cube</button>
                <button id="viewSphereBtn">Sphère</button>
            </div>
            <canvas id="threeCanvas"></canvas>
            <div style="margin-top: 10px; width: 100%;">
                <label for="roughnessSlider">Rugosité <span id="roughnessValue" class="value-display">0.6</span></label>
                <input type="range" id="roughnessSlider" min="0" max="1" value="0.6" step="0.01">
            </div>
        </div>
    </div>
</div>

<script>
    // Elements DOM
    const imageLoader = document.getElementById('imageLoader');
    const normalMapCanvas = document.getElementById('normalMapCanvas');
    const ctx = normalMapCanvas.getContext('2d');

    // Éléments pour l'aperçu principal
    const mainPreviewImage = document.getElementById('mainPreviewImage');
    const viewNormalBtn = document.getElementById('viewNormalBtn');
    const viewHeightmapBtn = document.getElementById('viewHeightmapBtn');
    const viewSourceBtn = document.getElementById('viewSourceBtn');
    const viewRoughBtn = document.getElementById('viewRoughBtn');
    const viewSwitcherBtns = [viewNormalBtn, viewHeightmapBtn, viewSourceBtn, viewRoughBtn];

    // Work canvases and source image (must be defined before reader.onload uses them)
    let sourceImage = new Image();
    let sourceCanvas = document.createElement('canvas');
    // willReadFrequently: utilisé car on appelle souvent getImageData sur ce canvas
    let sourceCtx = sourceCanvas.getContext('2d', { willReadFrequently: true });
    let heightmapCanvas = document.createElement('canvas');
    let heightmapCtx = heightmapCanvas.getContext('2d', { willReadFrequently: true });

    // Déclarations globales pour Babylon / matériel — évite ReferenceError lors du chargement d'une image
    let engine = null;
    let scene = null;
    let pbrMaterial = null;
    let cube = null;
    let sphere = null;
    let currentMesh = null;
    let hdrTexture = null;
    
    // Contrôles des options
    const intensitySlider = document.getElementById('intensity');
    const smallDetailsSlider = document.getElementById('smallDetails');
    const mediumDetailsSlider = document.getElementById('mediumDetails');
    const largeDetailsSlider = document.getElementById('largeDetails');
    
    const intensityValue = document.getElementById('intensityValue');
    const smallDetailsValue = document.getElementById('smallDetailsValue');
    const mediumDetailsValue = document.getElementById('mediumDetailsValue');
    const largeDetailsValue = document.getElementById('largeDetailsValue');

    const enableHeightmap = document.getElementById('enableHeightmap');
    const heightmapOptions = document.getElementById('heightmap-options');
    const hmLargeShapesSlider = document.getElementById('hmLargeShapes');
    const hmMediumDetailsSlider = document.getElementById('hmMediumDetails');
    const hmFineDetailsSlider = document.getElementById('hmFineDetails');
    const hmIntensitySlider = document.getElementById('hmIntensity');
    const hmSmoothingSlider = document.getElementById('hmSmoothing');

    const hmLargeShapesValue = document.getElementById('hmLargeShapesValue');
    const hmMediumDetailsValue = document.getElementById('hmMediumDetailsValue');
    const hmFineDetailsValue = document.getElementById('hmFineDetailsValue');
    const hmIntensityValue = document.getElementById('hmIntensityValue');
    const hmSmoothingValue = document.getElementById('hmSmoothingValue');

    const roughnessSlider = document.getElementById('roughnessSlider');
    const roughnessValue = document.getElementById('roughnessValue');

    // helper: retourne l'élément ou un dummy avec addEventListener() no-op et propriétés basiques
    function opt(id, defaults = {}) {
      const el = document.getElementById(id);
      if (el) return el;
      const d = {
        checked: defaults.checked || false,
        disabled: defaults.disabled || false,
        addEventListener: function() {},
      };
      return d;
    }
    const formatOpenGL = opt('formatOpenGL', { checked: true });
    const formatDirectX = opt('formatDirectX');
    const invertR = opt('invertR');
    const invertG = opt('invertG');
    const invertB = opt('invertB');

    // --- New roughness map helpers ---
    const roughDarkIntensity = document.getElementById('roughDarkIntensity');
    const roughLightIntensity = document.getElementById('roughLightIntensity');
    const roughDarkValue = document.getElementById('roughDarkValue');
    const roughLightValue = document.getElementById('roughLightValue');
    const levelsBlack = document.getElementById('levelsBlack');
    const levelsGamma = document.getElementById('levelsGamma');
    const levelsWhite = document.getElementById('levelsWhite');
    const levelsBlackValue = document.getElementById('levelsBlackValue');
    const levelsGammaValue = document.getElementById('levelsGammaValue');
    const levelsWhiteValue = document.getElementById('levelsWhiteValue');
    const invertRough = document.getElementById('invertRough');
    const regenerateRoughBtn = document.getElementById('regenerateRoughBtn');

    let roughnessCanvas = document.createElement('canvas');
    let roughnessCtx = roughnessCanvas.getContext('2d', { willReadFrequently: true });
    let roughnessDynamicTexture = null;

    function updateValueDisplay() {
        const intensityRaw = parseFloat(intensitySlider.value) / 100;
        const strength = Math.pow(intensityRaw, 2) * 2.5;
        intensityValue.textContent = strength.toFixed(2);
        smallDetailsValue.textContent = parseFloat(smallDetailsSlider.value).toFixed(2);
        mediumDetailsValue.textContent = parseFloat(mediumDetailsSlider.value).toFixed(2);
        largeDetailsValue.textContent = parseFloat(largeDetailsSlider.value).toFixed(2);
        
        hmLargeShapesValue.textContent = parseFloat(hmLargeShapesSlider.value).toFixed(2);
        hmMediumDetailsValue.textContent = parseFloat(hmMediumDetailsSlider.value).toFixed(2);
        hmFineDetailsValue.textContent = parseFloat(hmFineDetailsSlider.value).toFixed(2);
        hmIntensityValue.textContent = parseFloat(hmIntensitySlider.value).toFixed(2);
        hmSmoothingValue.textContent = parseFloat(hmSmoothingSlider.value).toFixed(1);

        roughnessValue.textContent = parseFloat(roughnessSlider.value).toFixed(2);
    }

    function handleFormatChange() {
        if (formatDirectX.checked) {
            invertG.checked = true;
            invertG.disabled = true;
        } else {
            invertG.checked = false;
            invertG.disabled = false;
        }
        generateNormalMap();
    }
    
    imageLoader.addEventListener('change', e => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = event => {
            sourceImage.onload = () => {
                sourceCanvas.width = sourceImage.width;
                sourceCanvas.height = sourceImage.height;
                heightmapCanvas.width = sourceImage.width;
                heightmapCanvas.height = sourceImage.height;
                normalMapCanvas.width = sourceImage.width;
                normalMapCanvas.height = sourceImage.height;

                // Créer/remplacer les textures 3D uniquement lors du chargement d'une nouvelle image
                if (pbrMaterial) {
                    if (pbrMaterial.albedoTexture) pbrMaterial.albedoTexture.dispose();
                    pbrMaterial.albedoTexture = new BABYLON.Texture(sourceImage.src, scene);

                    if (pbrMaterial.bumpTexture) pbrMaterial.bumpTexture.dispose();
                    pbrMaterial.bumpTexture = new BABYLON.DynamicTexture("normalMap", normalMapCanvas, scene, false);
                }

                generateHeightmap();
                setActiveView(viewNormalBtn); // Afficher la normal map par défaut
            };
            sourceImage.src = event.target.result;
        }
        reader.readAsDataURL(file);
    });

    const parameterControls = [
        intensitySlider, smallDetailsSlider, mediumDetailsSlider, largeDetailsSlider,
        invertR, invertG, invertB
    ];
    parameterControls.forEach(control => control.addEventListener('input', () => {
        updateValueDisplay();
        debouncedGenerateNormalMap(); // Utilise la version optimisée
    }));

    // Nouveaux écouteurs
    enableHeightmap.addEventListener('change', () => {
        heightmapOptions.style.display = enableHeightmap.checked ? 'block' : 'none';
        generateHeightmap(); // Le clic est instantané, pas besoin de debounce ici
    });
    
    const hmSliders = [hmLargeShapesSlider, hmMediumDetailsSlider, hmFineDetailsSlider, hmIntensitySlider, hmSmoothingSlider];
    hmSliders.forEach(slider => {
        slider.addEventListener('input', () => {
            updateValueDisplay();
            debouncedGenerateHeightmap(); // Utilise la version optimisée
        });
    });
    
    roughnessSlider.addEventListener('input', () => {
        if (pbrMaterial) {
            pbrMaterial.roughness = parseFloat(roughnessSlider.value);
        }
        updateValueDisplay();
    });

    // safe: if formatOpenGL/formatDirectX are missing, opt() gave un stub avec addEventListener() no-op
    formatOpenGL.addEventListener('change', handleFormatChange);
    formatDirectX.addEventListener('change', handleFormatChange);
    
    function getPixel(imageData, x, y) {
        // wrap coordinates so edges behave as tiled (repeat)
        const w = imageData.width, h = imageData.height;
        // positive modulo
        let xr = x % w; if (xr < 0) xr += w;
        let yr = y % h; if (yr < 0) yr += h;
        const i = (yr * w + xr) * 4;
        return imageData.data[i] * 0.299 + imageData.data[i + 1] * 0.587 + imageData.data[i + 2] * 0.114;
    }

    function generateHeightmap() {
        if (!sourceImage.src) return;
        const width = sourceCanvas.width;
        const height = sourceCanvas.height;

        heightmapCtx.clearRect(0, 0, width, height);

        if (enableHeightmap.checked) {
            const largeShapesStrength = parseFloat(hmLargeShapesSlider.value);
            const mediumDetailsStrength = parseFloat(hmMediumDetailsSlider.value);
            const fineDetailsStrength = parseFloat(hmFineDetailsSlider.value);
            const intensity = parseFloat(hmIntensitySlider.value);
            const smoothing = parseFloat(hmSmoothingSlider.value);

            // --- Étape 1: Créer les couches multi-échelle ---
            const tempCanvas1 = document.createElement('canvas');
            const tempCtx1 = tempCanvas1.getContext('2d', { willReadFrequently: true });
            tempCanvas1.width = width;
            tempCanvas1.height = height;

            const tempCanvas2 = document.createElement('canvas');
            const tempCtx2 = tempCanvas2.getContext('2d', { willReadFrequently: true });
            tempCanvas2.width = width;
            tempCanvas2.height = height;

            // Couche de base en niveaux de gris (détails fins)
            tempCtx1.filter = 'grayscale(1)';
            tempCtx1.drawImage(sourceImage, 0, 0);
            tempCtx1.filter = 'none';
            const fineData = tempCtx1.getImageData(0, 0, width, height).data;

            // Couche flou moyen
            tempCtx2.filter = 'blur(2px)';
            tempCtx2.drawImage(tempCanvas1, 0, 0);
            tempCtx2.filter = 'none';
            const mediumData = tempCtx2.getImageData(0, 0, width, height).data;

            // Couche flou large
            tempCtx1.filter = 'blur(8px)';
            tempCtx1.drawImage(tempCanvas1, 0, 0);
            tempCtx1.filter = 'none';
            const largeData = tempCtx1.getImageData(0, 0, width, height).data;

            // --- Étape 2: Fusion et Normalisation ---
            const combinedValues = new Float32Array(width * height);
            let min = Infinity, max = -Infinity;

            for (let i = 0; i < fineData.length; i += 4) {
                const v_fine = fineData[i];
                const v_medium = mediumData[i];
                const v_large = largeData[i];

                const largeComponent = v_large * largeShapesStrength;
                const mediumComponent = (v_medium - v_large) * mediumDetailsStrength;
                const fineComponent = (v_fine - v_medium) * fineDetailsStrength;
                
                const finalValue = largeComponent + mediumComponent + fineComponent;
                combinedValues[i / 4] = finalValue;

                if (finalValue < min) min = finalValue;
                if (finalValue > max) max = finalValue;
            }

            const finalImageData = heightmapCtx.createImageData(width, height);
            const finalData = finalImageData.data;
            const range = max - min;

            for (let i = 0; i < combinedValues.length; i++) {
                let normalized = 0;
                if (range > 0.001) {
                    normalized = 255 * (combinedValues[i] - min) / range;
                }
                
                const j = i * 4;
                finalData[j] = finalData[j + 1] = finalData[j + 2] = normalized;
                finalData[j + 3] = 255;
            }
            
            // --- Étape 3: Post-traitement (Intensité et Lissage) ---
            for (let i = 0; i < finalData.length; i += 4) {
                let val = finalData[i];
                val = ((val / 255 - 0.5) * intensity + 0.5) * 255;
                val = Math.max(0, Math.min(255, val));
                finalData[i] = finalData[i + 1] = finalData[i + 2] = val;
            }
            
            heightmapCtx.putImageData(finalImageData, 0, 0);

            if (smoothing > 0) {
                tempCtx1.clearRect(0, 0, width, height);
                tempCtx1.drawImage(heightmapCanvas, 0, 0);
                heightmapCtx.clearRect(0, 0, width, height);
                heightmapCtx.filter = `blur(${smoothing}px)`;
                heightmapCtx.drawImage(tempCanvas1, 0, 0);
                heightmapCtx.filter = 'none';
            }
        } else {
            // Si désactivé, on utilise juste l'image source
            heightmapCtx.drawImage(sourceImage, 0, 0);
        }

        generateNormalMap();
        // also regenerate roughness map when heightmap regenerated
        debouncedGenerateRoughness();
    }

    function generateNormalMap() {
        if (!sourceImage.src) return;

        const width = heightmapCanvas.width;
        const height = heightmapCanvas.height;
        
        // Échelle logarithmique pour l'intensité pour un meilleur contrôle des basses valeurs
        const intensityRaw = parseFloat(intensitySlider.value) / 100; // 0 to 1
        const strength = Math.pow(intensityRaw, 2) * 2.5; // 0 to 2.5, avec plus de précision en bas
        
        const sStr = parseFloat(smallDetailsSlider.value);
        const mStr = parseFloat(mediumDetailsSlider.value);
        const lStr = parseFloat(largeDetailsSlider.value);

        // --- NOUVELLE LOGIQUE DE LISSAGE ---
        const maxBlur = 4; 
        const blurAmount = 1.0 - sStr;
        const blurRadius = maxBlur * Math.pow(blurAmount, 2);

        sourceCtx.clearRect(0, 0, width, height);
        sourceCtx.filter = `blur(${blurRadius}px)`;
        sourceCtx.drawImage(heightmapCanvas, 0, 0); // Utilise la heightmap comme source
        sourceCtx.filter = 'none';

        const srcData = sourceCtx.getImageData(0, 0, width, height);
        const destImageData = ctx.createImageData(width, height);
        const destData = destImageData.data;

        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const n_x1 = getPixel(srcData, x - 1, y), n_x2 = getPixel(srcData, x + 1, y);
                const n_y1 = getPixel(srcData, x, y - 1), n_y2 = getPixel(srcData, x, y + 1);
                const m_x1 = getPixel(srcData, x - 2, y), m_x2 = getPixel(srcData, x + 2, y);
                const m_y1 = getPixel(srcData, x, y - 2), m_y2 = getPixel(srcData, x, y + 2);
                const l_x1 = getPixel(srcData, x - 4, y), l_x2 = getPixel(srcData, x + 4, y);
                const l_y1 = getPixel(srcData, x, y - 4), l_y2 = getPixel(srcData, x, y + 4);
                
                let dx = (n_x2 - n_x1) * sStr + (m_x2 - m_x1) * mStr + (l_x2 - l_x1) * lStr;
                let dy = (n_y2 - n_y1) * sStr + (m_y2 - m_y1) * mStr + (l_y2 - l_y1) * lStr;

                let normal = { x: -dx * strength, y: -dy * strength, z: 1.0 };
                
                const len = Math.sqrt(normal.x*normal.x + normal.y*normal.y + normal.z*normal.z);
                if (len > 0) { normal.x /= len; normal.y /= len; normal.z /= len; }

                let r = (normal.x * 0.5 + 0.5) * 255;
                let g = (normal.y * 0.5 + 0.5) * 255;
                let b = (normal.z * 0.5 + 0.5) * 255;

                if (invertR.checked) r = 255 - r;
                if (invertG.checked) g = 255 - g;
                if (invertB.checked) b = 255 - b;

                const index = (y * width + x) * 4;
                destData[index] = r;
                destData[index + 1] = g;
                destData[index + 2] = b;
                destData[index + 3] = 255;
            }
        }
        ctx.putImageData(destImageData, 0, 0);
        
        // Mettre à jour l'aperçu principal si la vue active est la heightmap
        if (viewHeightmapBtn.classList.contains('active')) {
            mainPreviewImage.src = heightmapCanvas.toDataURL();
        }
        updateBabylonTextures();
        // keep roughness in sync with normal/height changes
        debouncedGenerateRoughness();
    }
    
    function setActiveView(activeBtn) {
        viewSwitcherBtns.forEach(btn => btn.classList.remove('active'));
        activeBtn.classList.add('active');

        const view = activeBtn.id;
        if (view === 'viewNormalBtn') {
            mainPreviewImage.style.display = 'none';
            normalMapCanvas.style.display = 'block';
        } else {
            if (view === 'viewHeightmapBtn') {
                mainPreviewImage.src = heightmapCanvas.toDataURL();
            } else if (view === 'viewSourceBtn') {
                mainPreviewImage.src = sourceImage.src;
            } else if (view === 'viewRoughBtn') {
                // show generated roughness preview
                // roughnessCanvas est créé dans le code de génération de roughness
                mainPreviewImage.src = roughnessCanvas.toDataURL();
            }
            mainPreviewImage.style.display = 'block';
            normalMapCanvas.style.display = 'none';
        }
    }

    viewNormalBtn.addEventListener('click', () => setActiveView(viewNormalBtn));
    viewHeightmapBtn.addEventListener('click', () => setActiveView(viewHeightmapBtn));
    viewSourceBtn.addEventListener('click', () => setActiveView(viewSourceBtn));
    viewRoughBtn.addEventListener('click', () => setActiveView(viewRoughBtn));

    // --- Initialisation de la scène 3D ---
    initBabylon();

    function initBabylon() {
        const babylonCanvas = document.getElementById('threeCanvas');
        engine = new BABYLON.Engine(babylonCanvas, true, { preserveDrawingBuffer: true, stencil: true });
        scene = new BABYLON.Scene(engine);

        const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, INITIAL_CAMERA_ZOOM, new BABYLON.Vector3(0, 0, 0), scene);
        camera.attachControl(babylonCanvas, true);
        // CORRIGÉ : Suppression complète de la gestion du zoom pour éviter les bugs
        camera.inputs.remove(camera.inputs.attached.mousewheel);

        hdrTexture = new BABYLON.CubeTexture.CreateFromPrefilteredData("https://assets.babylonjs.com/environments/environmentSpecular.env", scene);
        scene.environmentTexture = hdrTexture;
        scene.createDefaultSkybox(hdrTexture, true, 1000, 0.0);

        // Permet la rotation de l'HDRI avec MAJ + Clic Gauche
        let hdrRotationY = 0;
        let isRotatingHDR = false;
        scene.onPointerObservable.add((pointerInfo) => {
            switch (pointerInfo.type) {
                case BABYLON.PointerEventTypes.POINTERDOWN:
                    if (pointerInfo.event.shiftKey && pointerInfo.event.button === 0) {
                        isRotatingHDR = true;
                        camera.detachControl();
                    }
                    break;
                case BABYLON.PointerEventTypes.POINTERUP:
                    if (isRotatingHDR) {
                        isRotatingHDR = false;
                        camera.attachControl(babylonCanvas, true);
                    }
                    break;
                case BABYLON.PointerEventTypes.POINTERMOVE:
                    if (isRotatingHDR) {
                        hdrRotationY -= pointerInfo.event.movementX * 0.01;
                        hdrTexture.setReflectionTextureMatrix(BABYLON.Matrix.RotationY(hdrRotationY));
                    }
                    break;
            }
        });

        pbrMaterial = new BABYLON.PBRMaterial("pbr", scene);
        pbrMaterial.metallic = 0.2;
        pbrMaterial.roughness = 0.6;

        cube = BABYLON.MeshBuilder.CreateBox("cube", {size: 1}, scene);
        cube.material = pbrMaterial;

        sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: 1.4, segments: 64}, scene);
        sphere.material = pbrMaterial;
        sphere.setEnabled(false);

        currentMesh = cube;

        const viewCubeBtn = document.getElementById('viewCubeBtn');
        const viewSphereBtn = document.getElementById('viewSphereBtn');

        viewCubeBtn.addEventListener('click', () => {
            if (currentMesh !== cube) {
                cube.setEnabled(true);
                sphere.setEnabled(false);
                currentMesh = cube;
                viewCubeBtn.classList.add('active');
                viewSphereBtn.classList.remove('active');
            }
        });

        viewSphereBtn.addEventListener('click', () => {
            if (currentMesh !== sphere) {
                sphere.setEnabled(true);
                cube.setEnabled(false);
                currentMesh = sphere;
                viewSphereBtn.classList.add('active');
                viewCubeBtn.classList.remove('active');
            }
        });
        
        engine.runRenderLoop(() => {
            scene.render();
        });

        window.addEventListener('resize', () => {
            engine.resize();
        });
    }

    function updateBabylonTextures() {
        // Mettre à jour uniquement la DynamicTexture de la normal map.
        // L'albedo ne change pas avec les curseurs.
        if (pbrMaterial && pbrMaterial.bumpTexture) {
             pbrMaterial.bumpTexture.update();
        }
        // update roughness/metallic dynamic texture if present
        if (roughnessDynamicTexture && roughnessDynamicTexture.update) {
          try { roughnessDynamicTexture.update(); } catch(e){ /* ignore */ }
        } else if (pbrMaterial && pbrMaterial.roughnessTexture && pbrMaterial.roughnessTexture.update) {
          try { pbrMaterial.roughnessTexture.update(); } catch(e){/*ignore*/ }
        }
     }

    // --- end new roughness helpers ---
    updateValueDisplay();
    handleFormatChange();
    // generate initial roughness if image already loaded
    debouncedGenerateRoughness();
</script>

</body>
</html>